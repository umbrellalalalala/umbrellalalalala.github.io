<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="C," />










<meta name="description" content="C语言是博主最先学的语言，但接触机器学习以来，主要编程语言变成了python，为了防止对C语言的淡忘，利用谭浩强C语言系列进行查漏补缺，进行易忘概念总结。 基础知识1、一个C程序的执行是从本程序的main函数开始，到main函数结束；2、C语言本身没有输入输出语句（只有输入输出函数）；3、C语言规定，在源程序中main函数的位置可以任意；4、一个C语言程序是由: \small\left\{ \be">
<meta name="keywords" content="C">
<meta property="og:type" content="article">
<meta property="og:title" content="C语言——基础查漏补缺（一）">
<meta property="og:url" content="https://yoursite.com/2019/02/15/C语言——基础查漏补缺（一）/index.html">
<meta property="og:site_name" content="Umbrellalalalala&#39;s blog">
<meta property="og:description" content="C语言是博主最先学的语言，但接触机器学习以来，主要编程语言变成了python，为了防止对C语言的淡忘，利用谭浩强C语言系列进行查漏补缺，进行易忘概念总结。 基础知识1、一个C程序的执行是从本程序的main函数开始，到main函数结束；2、C语言本身没有输入输出语句（只有输入输出函数）；3、C语言规定，在源程序中main函数的位置可以任意；4、一个C语言程序是由: \small\left\{ \be">
<meta property="og:locale" content="en">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20190124135716365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VtYnJlbGxhbGFsYWxhbGE=,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2019-03-24T08:41:52.592Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C语言——基础查漏补缺（一）">
<meta name="twitter:description" content="C语言是博主最先学的语言，但接触机器学习以来，主要编程语言变成了python，为了防止对C语言的淡忘，利用谭浩强C语言系列进行查漏补缺，进行易忘概念总结。 基础知识1、一个C程序的执行是从本程序的main函数开始，到main函数结束；2、C语言本身没有输入输出语句（只有输入输出函数）；3、C语言规定，在源程序中main函数的位置可以任意；4、一个C语言程序是由: \small\left\{ \be">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/20190124135716365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VtYnJlbGxhbGFsYWxhbGE=,size_16,color_FFFFFF,t_70">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yoursite.com/2019/02/15/C语言——基础查漏补缺（一）/"/>





  <title>C语言——基础查漏补缺（一） | Umbrellalalalala's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Umbrellalalalala's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Enjoy the symphony of the storm.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yoursite.com/2019/02/15/C语言——基础查漏补缺（一）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Umbrellalalalala">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Umbrellalalalala's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">C语言——基础查漏补缺（一）</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-02-15T19:29:29+08:00">
                2019-02-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/programming-languages/" itemprop="url" rel="index">
                    <span itemprop="name">programming languages</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>C语言是博主最先学的语言，但接触机器学习以来，主要编程语言变成了python，为了防止对C语言的淡忘，利用谭浩强C语言系列进行查漏补缺，进行易忘概念总结。</p>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>1、一个C程序的执行是从本程序的main函数开始，到main函数结束；<br>2、C语言本身没有输入输出语句（只有输入输出函数）；<br>3、C语言规定，在源程序中main函数的位置可以任意；<br>4、一个C语言程序是由:</p>
<script type="math/tex; mode=display">\small\left\{
\begin{aligned}
函数组成（\checkmark） \\
一个主程序和若干子程序组成（\times） \\
若干过程组成（\times）\\
若干子程序组成（\times）
\end{aligned}
\right.</script><p>5、C语言的源程序必须通过<strong>编译</strong>和<strong>链接</strong>后，才能被计算机执行；<br>6、在C语言源程序中，一个变量代表<strong>内存中的一个存储单元</strong>；<br>7、在Turbo C环境中用RUN命令运行一个C程序时，所运行程序的后缀是<code>.exe</code>；<br><a id="more"></a><br>8、C语言源程序文件的后缀是<code>.c</code>，经过编译后，生成文件的后缀是<code>.obj</code>，经过连接后，生成文件的后缀是<code>.exe</code>；<br>9、C语言源程序的基本单位是函数；<br>10、一个C语言源程序是由若干函数组成，其中<strong>至少应含有一个主函数（main）</strong>；</p>
<p>11、<strong>C和C++的不同</strong>：C++是以C语言为基础的面向对象程序设计语言，对于C89而言，因为C++标准包容了C89的所有内容，所以实现了其全部特性，但对于C99而言，其部分特性未包含到C++中。C语言源文件的扩展名是<code>.c</code>，C++的是<code>.cpp</code>；<br>12、<strong>原码、反码和补码</strong>：原码是在真值的基础上，最高位用1表示正号，用0表示负号；正数的反码、补码和原码相同；负数的反码是原码除负号位外取反，补码是在反码基础上末位加1;<br><strong>13</strong>、C编译器对数据的<strong>三种内存分配方式</strong>（书上说对数据区的内存分配需要认真研究）：<br>（1）在静态数据区中分配：静态数据区中的变量在C程序编译的时候就分配完成并初始化，这些变量称为静态型变量，其生命周期贯穿程序的整个运行周期。外部变量、static变量都在静态数据区中分配存储单元（这里内容有个小小的bug，如果我将程序进行编译后迟迟不去运行，那是不是被分配的内存空间就一直被这个程序的静态型变量占用？我认为这里应该是做了个假设：“编译完就立刻装入内存运行”，否则静态型变量应当也是程序要被运行时才分配内存，只不过是编译时就先确定“其一定会被分配内存（同时就确定了所需内存大小）”且将程序装入内存时就为之分配内存，分配完成才进行程序执行的下一步）；<br>（2）在动态数据区的堆栈上分配：C程序在函数内或者语句块内声明的变量是内部变量，它就在堆栈上分配存储空间。这部分存储空间中的变量随时可能消失，调用函数时，这部分变量就在堆栈上分配存储空间，当函数调用结束时，这部分存储空间会被自动释放，这些变量就不存在了；<br>（3）在动态数据区的堆上分配：需要程序员自己负责变量的分配和释放。需要使用C语言的指针来管理、操作这部分内存。</p>
<h1 id="C语言基本要素"><a href="#C语言基本要素" class="headerlink" title="C语言基本要素"></a>C语言基本要素</h1><p>1、<code>system(&quot;PAUSE&quot;)</code>的功能是产生一个DOS系统功能调用，等待键盘输入一个字符。在输入前屏幕暂停在当前位置，方便观察结果。此函数不是必须的，但若用之，需加<code>#include&lt;stdlib.h&gt;</code>；<br>2、<code>return 0</code>的功能是退出main函数，返回操作系统；<br>3、用户自定义函数可以在main函数之后定义，但必须在main函数之前声明；<br>4、<code>printf()</code>和<code>scanf()</code>在<code>stdio.h</code>中，都是<strong>标准库函数</strong>；<br>5、<strong>开发过程</strong>：<strong>编辑</strong>、<strong>编译</strong>（利用编译器，得到计算机可识别处理的二进制代码）、<strong>连接</strong>（将多个目标代码或者库函数代码连接起来）、<strong>装载运行</strong>（将连接后的程序装载到计算机内存，运行并得到结果）；<br>8、每个C程序都必须且只能有一个<strong>main函数</strong>；<br>9、C99标准中，main函数<strong>必须</strong>返回int型，即<code>void main(void)</code>是错误的，另外，要用<code>int main(void)</code><strong>明确声明</strong>main函数没有参数；C89可以返回void型，默认返回int型；<br>10、包含在函数名后面一对大括号中的部分就是<strong>函数体</strong>，C89要求变量的定义语句应该放在函数体中语句块的开头，C99则无这个要求（一般为了满足C89的要求，会将变量定义语句放在语句块开头）；</p>
<h2 id="变量、常量和数据类型"><a href="#变量、常量和数据类型" class="headerlink" title="变量、常量和数据类型"></a>变量、常量和数据类型</h2><p>11、用const定义的常量称为<strong>常变量</strong>，是不可改变的，可以通过初始化（定义时赋值）或者外部硬件因素修改其值，但不能通过赋值语句；<br>12、<strong>转义字符</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">字符值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\‘</td>
<td style="text-align:center">‘</td>
</tr>
<tr>
<td style="text-align:center">\“</td>
<td style="text-align:center">“</td>
</tr>
<tr>
<td style="text-align:center">\?</td>
<td style="text-align:center">?</td>
</tr>
<tr>
<td style="text-align:center">\\</td>
<td style="text-align:center">\</td>
</tr>
<tr>
<td style="text-align:center">\a</td>
<td style="text-align:center">警告（产生声音或视觉信号）</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">退格（backspace），当前位置后退一个字符</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页（form feed），当前位置移到下一页开头</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车（carriage return），当前位置移到本行开头</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">水平制表符，当前位置移到下一个tab位置</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">垂直制表符，当前位置移到下一个垂直制表对齐点</td>
</tr>
<tr>
<td style="text-align:center">\o、\oo、\ooo，o代表一位八进制数</td>
<td style="text-align:center">与该八进制码对应的ascii字符</td>
</tr>
<tr>
<td style="text-align:center">\xh[h…]，h代表一位十六进制数</td>
<td style="text-align:center">与该十六进制码对应的ascii字符</td>
</tr>
</tbody>
</table>
</div>
<p>13、用<code>&quot;&quot;</code>将若干字符括起来，但不能用<code>&#39;</code>，这个只能包含一个字符；<br>14、用<code>#define</code>定义的常量为符号常量，习惯上用大写表示，预编译后，符号常量就不存在了，比如<code>#define Pi 3.1415926</code>，预编译后，Pi被全部置换成3.1415926；<br>15、<strong>常量</strong>在程序运行期间，值不能改变，变量的值可以改变。变量必须<strong>先定义，后使用</strong>；<br>16、常变量是有名字的不变量，常量是没有名字的不变量（有名字便于在程序中被引用）。常变量具有变量的基本属性：有类型、占存储单元，只是不允许改变；<br>17、<strong>合法标识符</strong>：只能由字母、数字、下划线组成，且第一个字符必须为字母或者下划线（而不能是数字）；<br>18、<strong>整型数据</strong>：C标准要求<code>sizeof(short)≤sizeof(int)≤sizeof(long)≤sizeof(long long)</code>，通常是把long定为32位，把short定为16位，而int可以是16位或者32位。书上没提long long通常多少位，但表格中long long有8字节，即64位；<br>19、只有整型（包括字符型）可以加signed和unsigned修饰符，实行数据不能加。对无符号整型数据用“%u”格式输出，这个代表输出无符号十进制数的格式；<br>20、给无符号整型变量赋值负数的案例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> x = <span class="number">-1</span>；</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x)；</span><br></pre></td></tr></table></figure>
<p>输出结果是65535，因为系统会将-1转换成补码形式，由于是short型（16位），即系统用十六个1表示-1的补码。但由于x是unsigned型，所以输出时会认为这是非负数，非负数的原码和补码一致，故输出65535；<br>21、由于字符是按照其代码（整数）形式存储的，因此C99单独把<strong>字符型数据</strong>作为整型数据的一种。几种重要字符的ascii代码：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">ASCII代码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">A</td>
<td style="text-align:center">65</td>
</tr>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">97</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">49</td>
</tr>
<tr>
<td style="text-align:center">‘ ‘(空格字符)</td>
<td style="text-align:center">32</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">37</td>
</tr>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
</div>
<center>大写字母的ASCII码加32为对应的小写字母</center>

<p>22、字符’1’和整数1的区别：前者只是形状为’1’的符号，在内存中占一个字节以ascii码（49）存储，后者占两个字节，以二进制补码方式存储。⚠️注意’1’+’1’不等于’2’；<br>23、用char定义的变量是字符变量，用%d打印出来是其ascii码的值，用%c打印出来是这个字符本身；<br>24、字符型数据可以是signed或者unsigned的，不加这个符号时，默认是signed char还是unsigned char需要由编译器决定。将负数赋值给有符号字符型数据是合法的，但它不代表一个字符，而是作为一字节整型变量存储负整数；<br>25、总结一下<strong>浮点数取值范围</strong>，浮点数值为：</p>
<script type="math/tex; mode=display">尾数\times底数^{指数}</script><p>对于float：1bit（符号位）+8bits（指数位）+23bits（尾数位）；<br>对于double：1bit（符号位）+11bits（指数位）+52bits（尾数位）。<br>（补充概念：<strong>规范化的指数形式</strong>指的是小数点前为0，小数点后第一位不为0）<br>尾数最大近似为1，浮点数的范围主要就和指数部分有关，float的指数部分范围是-127～128，底数为2。128代表浮点数范围两头最大和最小是多少，-127代表浮点数范围中最接近0的点应该是多少，所以float的两头范围大致就是$-2^{128}$ ~ $2^{128}$，即$-3.4\times10^{38}$ ~ $3.4\times10^{38}$,同理计算出最靠近0的部分就是$(-)1.2\times10^{-38}$，double型的计算过程略，谭浩强教材中有一张表：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">字节数</th>
<th style="text-align:center">有效数字</th>
<th style="text-align:center">数值范围（绝对值）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">float</td>
<td style="text-align:center">4</td>
<td style="text-align:center">6</td>
<td style="text-align:center">0以及$1.2\times10^{-38}$~$3.4\times10^{38}$</td>
</tr>
<tr>
<td style="text-align:center">double</td>
<td style="text-align:center">8</td>
<td style="text-align:center">15</td>
<td style="text-align:center">0以及$2.3\times10^{-308}$~$1.7\times10^{308}$</td>
</tr>
<tr>
<td style="text-align:center">long double（Visual C++ 6.0编译器）</td>
<td style="text-align:center">8</td>
<td style="text-align:center">15</td>
<td style="text-align:center">0以及$2.3\times10^{-308}$~$1.7\times10^{308}$</td>
</tr>
<tr>
<td style="text-align:center">long double（Turbo C编译器）</td>
<td style="text-align:center">16</td>
<td style="text-align:center">19</td>
<td style="text-align:center">0以及$3.4\times10^{-4932}$~$1.1\times10^{4932}$</td>
</tr>
</tbody>
</table>
</div>
<p>对于float的有效数字，由于float的尾数有23位，即$2^{23} = 8388608$，共七位，意味着最多能有7位有效数字，但绝对能保证的为6位，所以有效数字定为6位，这个也代表精度。其他类型的有效数字推算略，推算不是重点，将上图各个类型的大致范围记住，方便编程就足够了；<br>26、C程序中的实型常量都是双精度浮点型常量；</p>
<h2 id="算数运算和数据存储"><a href="#算数运算和数据存储" class="headerlink" title="算数运算和数据存储"></a>算数运算和数据存储</h2><p>27、整除运算符<code>/</code>：多数C编译系统采取“向零取整”，<code>5/3 = 1</code>，<code>-5/3 = -1</code>；<br>28、求余运算符<code>%</code>：参加运算的运算对象为整数，结果也是整数。除了<code>%</code>以外的其他运算符的操作数都可以是任何算数类型；<br>29、运算符的优先级和结合性：优先级相同的情况下，算术运算符的结合方向都是<strong>先左后右</strong>（左结合性）；<br>30、<strong>不同类型数据间混合运算</strong>：<br>int、float、double两两之间进行运算，先将非double型（包括float）的转化为double型，再进行运算，运算结果为double型；<br>char型可以直接和int型进行运算（不需要类型转换）；<br>char型和float或者double型进行运算，char型和float型会先被转化为double型；<br>31、强制类型转换：<strong>(类型名)(表达式)</strong>，比如<code>b = (double)a</code>就是将a的值强制转化为double型赋给b，但a的类型和值都没有发生变化；</p>
<p>⚠️由于<code>%</code>要求两侧数字都是整型的，令f为浮点型数据，则<code>f%3</code>不合法，可写成<code>(int)f%3</code>；</p>
<p>32、<strong>赋值过程的类型转换</strong><br>将浮点型（包括单精度和双精度）赋给整型时，先舍弃浮点型数据的小数部分然后再赋予整型变量：<br><code>int i; i = 3.56;</code>运行结果是i为3；<br>将整型数据赋给浮点型数据时，数值不变，以浮点数形式存储到变量中；<br>将double型赋给float时，先将双精度转换为单精度，只取6～7位有效数字，存储到float变量的4个字节中；</p>
<p>⚠️双精度范围比单精度大，不要将单精度无法存储的大数赋值给单精度变量；</p>
<p>字符型数据给整型数据赋值，将前者的ASCII赋给后者；<br>多字节的整型数据赋给少字节的整型数据，比如占4字节的int赋给2字节的short，或者1字节的char，将其低字节原封不动地送到被赋值的变量，此过程叫“截断”；</p>
<p><strong>33、⚠️关于补码的注意事项</strong>：<br>以下两个横线之间的内容参考了其他博客，觉得其对+0和-0和-32768的补码来源很有参考价值：</p>
<hr>
<p>正0和负0的原码：0000000000000000和1000000000000000，补码表现中，两者都是0000000000000000，也就是正0和负0在补码系统中的编码是一样的，</p>
<p>而任何一个原码都不可能在转成补码时变成1000000000000000（这个是-0的原码），</p>
<p>所以，人为规定1000000000000000这个-0的原码来表示-32768的补码。所以，补码系统中，范围是-32768～32767（原码系统中则是-32767～32767）。</p>
<p>此处参考原文：<a href="https://blog.csdn.net/chen_tongsheng/article/details/79011390" target="_blank" rel="noopener">https://blog.csdn.net/chen_tongsheng/article/details/79011390</a> </p>
<hr>
<p>-127的补码是10000000的道理和上面一样，<strong>只要是第一位是1，剩下全0的补码，都可视为用-0的原码充当的补码</strong>。</p>
<p>再来一张图辅助理解原码、补码和反码，留意其中对-8补码来源的解释（-0和+0的补码相同，所以用-0的原码来表示-8的补码）：<br><img src="https://img-blog.csdnimg.cn/20190124135716365.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3VtYnJlbGxhbGFsYWxhbGE=,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>（在此友情提醒，谭浩强的C第四版图3.16(b)可能有错，应该是第一位1，后面15个0）</p>
<p>34、<code>int a, b, c = 5</code>只会对c赋值，若要对三者都赋值5，可写成：<code>int a=5, b=5, c=5</code>；</p>
<h2 id="输入输出函数"><a href="#输入输出函数" class="headerlink" title="输入输出函数"></a>输入输出函数</h2><p>35、<strong>printf</strong>：<br>（1）如果整数的范围在0～127的范围内，那么用<code>%c</code>占位符可以输出ASCII码相对应的字符，如果超过这个范围，则考虑最后一个字节的字符进行输出。比如以下两种方式均输出字符y（ASCII码为121或者01111001）：<br>方式一</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> a = <span class="number">121</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br></pre></td></tr></table></figure>
<p>方式二</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">377</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, a);</span><br></pre></td></tr></table></figure>
<p>（2）<code>-m.nf%</code>代表输出数据占总列数（含小数点）为m，小数点后占的列数为n，<strong>左对齐</strong>；<br>（3）<code>%e</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%e"</span>, <span class="number">123.456</span>);</span><br></pre></td></tr></table></figure>
<p>如上，如果不指定宽度，很多编译系统中的输出结果是：<br><code>1.234560e+002</code>，意思是$1.234560\times10^2$。也可以利用<code>%m.ne%</code>的形式指定宽度：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%13.2e"</span>, <span class="number">123.456</span>);</span><br></pre></td></tr></table></figure></p>
<p>输出结果是：<br><code>()1.23e+002</code>，“()”代表四个空格，这样总长度是13；<br>（4）<code>%i</code>作用同%d，按照十进制整数数据的实际长度输出，一般用%d而不是这个；<br>（5）<code>%o</code>以八进制整数形式输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">-1</span>;		<span class="comment">//假设系统规定int占4字节</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%o\n"</span>, a);</span><br></pre></td></tr></table></figure>
<p>得到结果是<code>37777777777</code>，因为-1在内存单元中是32个1（补码存储），八进制1位是二进制3位，所以有11位八进制数；<br>（6）<code>%u</code>无符号整型数据；<br>（7）<code>%g</code>：输出浮点数，系统自动选f格式或者e格式，选择长度较短的格式，不输出无意义的0；<br>36、<strong>scanf</strong>：<br>参数是格式和变量<strong>地址</strong>表列。<br>格式字符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">格式字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">d, i</td>
<td style="text-align:center">有符号十进制数</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">无符号十进制数</td>
</tr>
<tr>
<td style="text-align:center">o</td>
<td style="text-align:center">无符号八进制数</td>
</tr>
<tr>
<td style="text-align:center">x, X</td>
<td style="text-align:center">无符号十六进制数</td>
</tr>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">单个字符</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">输入字符串，将字符串送到一个字符数组中，以非空白字符开始，以第一个空白字符结束，并以’\0’作为最后一个字符</td>
</tr>
<tr>
<td style="text-align:center">f</td>
<td style="text-align:center">用来输入实数，可用小数形式或指数形式（双精度要用lf）</td>
</tr>
<tr>
<td style="text-align:center">e, E, g, G</td>
<td style="text-align:center">同f</td>
</tr>
</tbody>
</table>
</div>
<p>格式附加字符：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">输入长数据，可用%ld,%lo,%lx,%lu,%lf（双精度）,%le</td>
</tr>
<tr>
<td style="text-align:center">h</td>
<td style="text-align:center">输入短数据，可用%hde,%ho,%hx</td>
</tr>
<tr>
<td style="text-align:center">域宽</td>
<td style="text-align:center">正整数，指定输入数据所占宽度（列数）</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">表示本输入项在读入后不赋给相应变量</td>
</tr>
</tbody>
</table>
</div>
<p>37、putchar()，输出一个字符，参数可以是字符的ASCII码；<br>38、getchar()，输出一个字符。</p>
<p>⚠️键盘输入信息时，输入的字符先暂存在键盘的缓冲器中，只有按了enter键后才将字符送入计算机中，按照先后顺序分别赋给相应的变量。</p>
<p>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a, b, c;</span><br><span class="line">a = getchar();</span><br><span class="line">b = getchar();</span><br><span class="line">c = getchar();</span><br><span class="line"><span class="built_in">putchar</span>(a);</span><br><span class="line"><span class="built_in">putchar</span>(b);</span><br><span class="line"><span class="built_in">putchar</span>(c);</span><br><span class="line"><span class="built_in">putchar</span>(<span class="string">"\n"</span>);</span><br></pre></td></tr></table></figure>
<p>如果输入”BOY”，再按回车，那么三个字符进入计算机，然后分别赋值给a，b，c，这样在经过putchar()依次输出：<br><code>BOY</code><br>如果输入B、回车、O、回车，那么运行情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B</span><br><span class="line">O</span><br><span class="line">B</span><br><span class="line">O</span><br></pre></td></tr></table></figure>
<p>上述运行情况是这样的：输入B，B进入键盘缓冲区，输入回车，B和回车进入计算机，分别赋给a和b，然后再按O和回车，O赋给c，回车赋给下一个getchar()；输出的时候就依次输出a、b、c，分别是B、回车、O，然后再用putchar(“\n”)输出一个回车。注意程序运行之后，计算机中仍有个回车，如果再使用一个getchar()，这个回车就会被其接收。</p>
<h2 id="关系运算符和逻辑运算符"><a href="#关系运算符和逻辑运算符" class="headerlink" title="关系运算符和逻辑运算符"></a>关系运算符和逻辑运算符</h2><p>39、关系运算符和关系表达式：<br>大于、大于等于、小于、小于等于四种优先级高于等于和不等于；<br>a为3，b为2，c为1，则：<br><code>a&gt;b</code>值为真，表达式值为1；<br><code>(a&gt;b) == c</code>值为真，表达式值为1（注意a&gt;b成立，所以其值为1，等于c的值，所以表达式为真）；<br><code>f = a &gt; b &gt; c</code>，f为0，因为&gt;号是左结合的，先算a&gt;b，为真，即值为1，然后算1&gt;c，为假，值为0；<br>40、逻辑运算符优先级<strong>由高到低</strong>是非与或；</p>
<p>总的运算符优先级<strong>由高到低</strong>：<br>非、算数运算符、关系运算符、与或、赋值运算符；</p>
<p>⚠️表达式是从左向右扫描的，在扫描的过程中结合优先级进行判断。下列表达式结果是0:<br><code>5 &gt; 3 &amp;&amp; 8 &lt; 4 - !0</code></p>
<p><strong>分支结构</strong>要大量用到这一块的内容，顺便补充常见的逻辑判断：<br>闰年是能被4整除但不能被100整除的数，或者是能被400整除的数；</p>
<h2 id="分支和循环"><a href="#分支和循环" class="headerlink" title="分支和循环"></a>分支和循环</h2><p>41、两种分支语句<br>if不再赘述，主要复习使用较少的switch，以下是示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> grade;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%c"</span>, &amp;grade);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Your score:"</span>);</span><br><span class="line">	<span class="keyword">switch</span>(grade)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'A'</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"85~100\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'B'</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"70~84\n"</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		……</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"enter data error!\n"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A</span><br><span class="line">Your score:85~100</span><br></pre></td></tr></table></figure>
<p>default可以没有，且其在switch中的出现顺序不一定非要最后一个；<br>switch执行顺序是先计算grade的值，然后依次和各个case之后的值进行比较，找到匹配的则直接执行之，注意如果case中没有加break语句，则执行结束后顺序跳转到下一个case进行值的比较。如果没有case匹配，则执行default；</p>
<p>42、三种循环结构<br>for、while和do while，最后一种可以无条件循环一次，不是很常用。<br>一个重要例子：求100～200之间的所有素数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, k, i, m = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">101</span>; n&lt;=<span class="number">200</span>; n+=<span class="number">2</span>)&#123;</span><br><span class="line">		k = <span class="built_in">sqrt</span>(n);				<span class="comment">//用来求平方根，要求参数是双精度。执行时将整数n自动转化为双精度，</span></span><br><span class="line">									<span class="comment">//计算出来的函数值也是双精度的，赋给整型k后自动省略小数部分。</span></span><br><span class="line">		<span class="keyword">for</span>(i=<span class="number">2</span>; i&lt;=k; i++)</span><br><span class="line">			<span class="keyword">if</span>(n%i==<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">if</span>(i&gt;=k+<span class="number">1</span>)&#123;				<span class="comment">//表明n未曾被整除过</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"%d "</span>, n);</span><br><span class="line">			m += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(m%<span class="number">10</span>==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);		<span class="comment">//每行只输十个数字</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>43、数组的长度必须依赖于常量而不是变量，有种情况除外，那就是在被调用函数中定义的数组，其长度可以是变量或者非常量表达式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是合法的，此情况称为“可变长数组”。但注意在执行函数的时候，n的值是不变的，数组长度是固定的，且如果指定数组为静态（static）存储方式，则不能用“可变长数组”：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a[n];	<span class="comment">//不合法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>44、⭐️<strong>字符数组</strong><br>由于字符型数据是按照整数形式（ASCII）存放的，因此可以用整型数组存放它的数据：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> c[<span class="number">10</span>];</span><br><span class="line">c[<span class="number">0</span>] = <span class="string">'a'</span>;</span><br></pre></td></tr></table></figure>
<p>但是这样做浪费存储空间。</p>
<p>如果字符个数小于数组长度，比如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[<span class="number">10</span>] = &#123;<span class="string">'c'</span>, <span class="string">' '</span>, <span class="string">'p'</span>, <span class="string">'r'</span>, <span class="string">'o'</span>, <span class="string">'g'</span>, <span class="string">'r'</span>, <span class="string">'a'</span>, <span class="string">'m'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>那么数组的状态是这样的：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">c[0]</th>
<th style="text-align:center">c[1]</th>
<th style="text-align:center">c[2]</th>
<th style="text-align:center">c[3]</th>
<th style="text-align:center">c[4]</th>
<th style="text-align:center">c[5]</th>
<th style="text-align:center">c[6]</th>
<th style="text-align:center">c[7]</th>
<th style="text-align:center">c[8]</th>
<th style="text-align:center">c[9]</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">空格</td>
<td style="text-align:center">p</td>
<td style="text-align:center">r</td>
<td style="text-align:center">o</td>
<td style="text-align:center">g</td>
<td style="text-align:center">r</td>
<td style="text-align:center">a</td>
<td style="text-align:center">m</td>
<td style="text-align:center">\0</td>
</tr>
</tbody>
</table>
</div>
<p>其余的位置会自动补上“\0”，这个是空字符，编程时可以用这个判断数组末尾。<br>如果初值个数和数组长度相同，则不会在末尾补上这个空字符，而实际上，多数情况我们需要用这个“\0”来判断字符的有效长度，所以说定义字符数组时先估计字符串的长度，然后保证字符数组长度大于字符串的长度（当然是否需要“\0”还是用户来决定）。</p>
<p>上述有加“\0”和不加“\0”的情况，但下述情况必然会加“\0”（用字符串来初始化）:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">"deep dark fantasy"</span>&#125;</span><br><span class="line"><span class="keyword">char</span> c[] = <span class="string">"deep dark fantasy"</span>		<span class="comment">//这两行等价</span></span><br></pre></td></tr></table></figure>
<p>注意数组c的长度就不是17，而是18，因为要算上自动加上的“\0”。<br>但如果这样定义，就不会加“\0”：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c[] = &#123;<span class="string">'d'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'p'</span>, <span class="string">' '</span>, ……,<span class="string">'y'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>记住，只有用字符串初始化字符数组和（不管以什么形式初始化）数组长度超过字符串长的情况，才有“\0”。</p>
<p>使用<code>%s</code>输出字符串的时候，遇到第一个“\0”时，输出就结束。</p>
<p>利用一个scanf()输入多个字符串，需要以空格分离（多少个空格都一样）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">5</span>], str2[<span class="number">5</span>], str3[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s%s%s"</span>, str1, str2, str3);</span><br></pre></td></tr></table></figure>
<p>输入<code>how are you?</code>，三个字符数组的状态如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">h</th>
<th style="text-align:center">o</th>
<th style="text-align:center">w</th>
<th style="text-align:center">\0</th>
<th style="text-align:center">\0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">r</td>
<td style="text-align:center">e</td>
<td style="text-align:center">\0</td>
<td style="text-align:center">\0</td>
</tr>
<tr>
<td style="text-align:center">y</td>
<td style="text-align:center">o</td>
<td style="text-align:center">u</td>
<td style="text-align:center">?</td>
<td style="text-align:center">\0</td>
</tr>
</tbody>
</table>
</div>
<p>⚠️如果scanf输入项如果是字符数组名，就不要再加地址符，因为数组名就是数组的<strong>起始地址</strong>。</p>
<p><strong>string.h</strong>中的字符处理函数：<br>（1）<code>puts()</code>：将一个字符串（以“\0”结尾）输出到终端，输出的字符串可以包含转义字符，会将字符串结束标志的“\0”自动转换成“\n”。<br>（2）<code>gets()</code>：从标准输入（键盘）读取一行数据，遇到换行符就返回，并将换行符替换成“\0”，键盘输入<code>computer回车</code>，gets接收到的是9个字符，最后一个是空字符。这个函数比较危险，它不会检查数组能否装得下输入行，所以C99不建议使用此函数。<br>（3）<code>strcat(str1, str2)</code>：将str2接到str1后面，并将结果存储到str1中。将str1中的“\0”取消，只保留str2中的“\0”。<br>（4）<code>strcpy(str1, str2)</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[<span class="number">10</span>], str2[] = <span class="string">"China"</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(str1, str2);</span><br></pre></td></tr></table></figure>
<p>将str2中的前5个字符和其后的一个“\0”复制到str1中，取代其中前六个字符，但其后四个字符还是str1中原有的字符。<br>还有个扩展函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(str1, str2, <span class="number">2</span>);	<span class="comment">//将str2前2个字符复制到str1中，此处指定的复制个数不得超过str1原有的字符（不含“\0”）</span></span><br></pre></td></tr></table></figure>
<p>（5）<code>strcmp(str1, str2)</code>：字符串比较函数，从左至右依次比较ASCII码，直到遇到不相等或遇到“\0”的情况。若字符串相等，则返回0；若str1&gt;str2，则返回正数，反之负数。（字符串大小比较指的是ASCII码的比较）<br>（6）<code>strlen()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>] = <span class="string">"China"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">strlen</span>(str));</span><br></pre></td></tr></table></figure>
<p>输出结果是5，不包括最后的“\0”。<br>（7）大小写转换：<br>转换为小写：<code>strlwr()</code>；<br>转换为大写：<code>strupr()</code>；</p>
<h2 id="函数注意事项和变量作用域、生存周期"><a href="#函数注意事项和变量作用域、生存周期" class="headerlink" title="函数注意事项和变量作用域、生存周期"></a>函数注意事项和变量作用域、生存周期</h2><p>45、形式参数和实际参数：调用函数的过程中，实参的数据会传递给形参；<br>46、函数的返回值是通过函数中的return语句获得的；<br>47、对被调用函数的<strong>声明</strong>：在一个函数中调用另一个用户自定义函数之前，应当先对被调用函数进行声明。<strong>声明的作用</strong>是将函数名、函数参数个数和参数类型等信息通知编译系统，以便在遇到函数调用的时候，编译系统能够正确识别函数并检查调用是否合法。<br>在函数声明中，形参可以简写，只写形参的类型而不写名称；<br>如果已经在某函数之前对被调用函数进行了“外部声明”，则不需要在函数内部再进行声明。写在所有函数前面的外部声明在整个文件范围内有效；<br>如果函数在被调用之前进行了定义，则不需要在被调用之前进行声明；<br>48、<strong>数组作为函数参数</strong>：<br>（1）数组元素作实参时，向形参传递的是数组元素的值；<br>（2）用数组名作函数实参时，向形参（数组名或指针变量）传递的是数组首元素的地址；（数组名本身代表数组首元素的地址，C语言编译系统不检查形参数组大小，形参数组只获得实参数组首元素地址，形参数组可以不指定大小：<code>float average(float array[])</code>只用方括号表示这是数组，但不指定大小）；因为传递的是数组首地址，所以形参数组值发生变化时，会使得实参数组也发生变化；<br>（3）多维数组名作为函数参数：可以省略第一维大小说明，而不能省略第二维大小说明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][<span class="number">10</span>];	<span class="comment">//是对的</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">3</span>][];	<span class="comment">//是错的</span></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[][];		<span class="comment">//是错的</span></span><br></pre></td></tr></table></figure>
<p>原因：二维数组是由多个一维数组组成的，在内存中，数组是按行存放的，所以在定义二维数组时，必须指定列数（即一行中包含几个元素）。实参和形参必须是由相同长度的一维数组组成的，第二维相同的情况下，第一维可以不同，所以必须指定第二维大小；<br>49、<strong>局部变量和全局变量</strong>：<br>（1）在一个函数内部，可以在复合语句中定义变量，这些变量只在本复合语句中有效（复合语句就是用大括号包裹的几条语句）；（这种复合语句称为“<strong>分程序</strong>”或“<strong>程序块</strong>”）；<br>（2）函数（或程序块）内定义的变量是局部变量，函数外定义的变量是全局变量。前者的范围是自定义起到本程序块结束，后者的范围是自定义起到本源文件的结束；一个习惯是将全局变量名的第一个字母用大写表示；</p>
<p>为什么在不必要时尽量别用全局变量：<br>全局变量在程序全部执行过程中都占用存储单元，而不是仅在需要时才开辟单元；<br>降低函数通用性；降低程序清晰性；</p>
<p>50、变量存储方式和生存期：<br>（1）用户使用的存储空间分为：程序区、静态存储区、动态存储区，全局变量存放在静态存储区中，函数形参、函数中定义的未用static声明的变量（自动变量）、函数调用时的现场保护和返回地址都存放在动态存储区中；<br>（2）四种存储类别：自动的（auto）、静态的（static）、寄存器的（register）、外部的（extern），根据变量存储类别，可以知道变量的作用域和生存期；</p>
<p>也可将存储类别进一步划入局部和全局存储类别：</p>
<p><strong>三种局部变量存储类别：</strong></p>
<p>1）自动变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> <span class="keyword">int</span> b, c = <span class="number">3</span>;</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>调用该函数时，系统会给这类变量分配存储空间，在函数调用结束时就自动释放这些存储空间，auto可以省略，不写之则隐含指定为“自动存储类别”；</p>
<p>2）静态局部变量：有时希望函数中的局部变量值在函数调用结束后不消失而是继续保留原值，即占用的内存单元不释放，下一次再调用该函数的时候，该变量已有值就是上一次函数调用结束时的值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	……</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> a;	<span class="comment">//静态局部变量</span></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如非必要，不要使用静态局部变量，因为它多占内存，降低程序可读性，调用次数过多时，无法浓情静态局部变量当前值是多少；</p>
<p>3）寄存器变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> f;	<span class="comment">//f为寄存器变量</span></span><br></pre></td></tr></table></figure>
<p>寄存器的存取速度远高于内存的，所以对于使用频繁的变量可以使用这种方法提高速度；</p>
<p><strong>全局变量的存储类别：</strong></p>
<p>1）用extern扩展外部变量作用域：<br>如果外部变量不在文件的开头处定义，则有效范围只是定义位置到文件结束，用extern作“外部变量声明”，就可以从“声明”处起，合法使用该外部变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">extern</span> <span class="keyword">int</span> A, B, C;	<span class="comment">//使得外部变量A，B，C能合法地从此处使用到文件结束</span></span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> A, B, C;</span><br><span class="line"></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p><code>extern int A, B, C;</code>亦可以写成<code>extern A, B, C;</code>，因为这不是真正的变量定义；</p>
<p>2）用extern将一个文件定义的外部变量作用域扩展到另一个文件：<br>file1.c:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> A;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>file2.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> A;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>这样，file2也可以使用file1的外部变量A了；</p>
<p>3）将外部变量作用域限制在本文件中：<br>如果file1的主人不希望变量被file2拿去用，那么就可以：<br>file1.c:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> A;</span><br><span class="line">……</span><br></pre></td></tr></table></figure></p>
<p>这是如果file2.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> A;</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>就会出错。</p>
<p>⚠️不要以为对外部变量加static声明后才采取静态存储方式，而不加static的是采取动态存储。<br>真相是：<strong>对局部变量加static，则将其分配在静态存储区，该变量在其作用域结束后也暂不释放，而是坚挺到程序执行结束；对全局变量用static声明，则将该变量作用域限于本文件模块</strong>；</p>
<p>这一块内容要多加小心，auto和register声明不是很常见，重点掌握extern的用法，以及static对局部和全局变量的声明作用；</p>
<p><strong>小结</strong></p>
<p>对于数据，其有数据类型和存储类别两种属性，而存储类型对于全局和局部变量又可能有不同的功效（比如static声明全局或者局部变量功能不同）。下表汇总了不同类别的变量的可见性（能被引用）和生存期（存在）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">函数内能被引用</th>
<th style="text-align:center">函数内存在</th>
<th style="text-align:center">函数外能被引用</th>
<th style="text-align:center">函数外存在</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自动变量和寄存器变量</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\times$</td>
</tr>
<tr>
<td style="text-align:center">静态局部变量</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\times$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">静态外部变量</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\checkmark$（仅限本文件）</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
<tr>
<td style="text-align:center">外部变量</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\checkmark$</td>
<td style="text-align:center">$\checkmark$</td>
</tr>
</tbody>
</table>
</div>
<p>50、<strong>声明和定义</strong><br>声明包括定义，但声明并非都是定义。<br><strong>定义性声明</strong>（简称<strong>定义</strong>）举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a;</span><br></pre></td></tr></table></figure>
<p><strong>引用性声明</strong>举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> A;</span><br></pre></td></tr></table></figure>
<p>⚠️外部变量的定义只能有一次，它的位置在所有函数之外（外部和局部变量的区别就在于其定义位置在“外面”还是“里面”）。</p>
<p><strong>结论</strong></p>
<p>在函数内对变量的声明（extern除外）都是定义，在函数内对其他函数的声明不是函数的定义。</p>
<p>51、内部函数和外部函数<br>内部函数示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>内部函数只能被本文件中其他函数所调用，又称<strong>静态函数</strong>（名称来源与它是用static定义的）。</p>
<p>⚠️通常把只能由本文件使用的函数、外部变量放在文件的开头，前面都加上static使之局部化，其他文件都不能引用，这就提高了程序的可靠性。记住，加了static的东东只能在本文件使用。</p>
<p>外部函数示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这样，函数就能被其他文件所使用，如果省略extern，则默认为外部函数。</p>
<hr>
<p>以上部分所述C语言基本要素，构成了C语言的基本身躯，接下来总结指针，为C语言注入“灵魂”(指针被誉为C语言的灵魂)。</p>
<p>我偏爱用C++写面向过程的程序，因为它不仅包含了C语言的功能，还有一个不错的指针替代品——引用（自从学了引用，我几乎不用指针，除了接收数组的形参和malloc数组定义），除此之外还可以视情况添加面向对象的编程元素。</p>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h1><h2 id="指针基本概念"><a href="#指针基本概念" class="headerlink" title="指针基本概念"></a>指针基本概念</h2><p>1、指针变量<br>使用示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line">p1 = &amp;a;</span><br><span class="line">p2 = &amp;b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p1:"</span>, * p1);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"p2:"</span>, * p2);</span><br></pre></td></tr></table></figure>
<p>以上是指针变量的定义和指针指向内容的引用。</p>
<p>指针变量用作函数参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * p1, <span class="keyword">int</span> * p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = * p1;</span><br><span class="line">	* p1 = * p2;</span><br><span class="line">	* p2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码实现指针指向的两个存储单元内容互换，但写成以下这样就有问题了：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> * p1, <span class="keyword">int</span> * p2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> * temp;</span><br><span class="line">	* temp = * p1;</span><br><span class="line">	* p1 = * p2;</span><br><span class="line">	* p2 = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>⚠️由于未给temp赋值，因此temp无确定的值，所以temp指向的单元是未知的，此时对* temp赋值，就相当于改变未知单元的值，万一改变的是重要单元，那么可能会破坏系统正常工作状况。</p>
<p>如果执行以下语句，则互换作用无法达成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp;</span><br><span class="line">	temp = x;</span><br><span class="line">	x = y;</span><br><span class="line">	y = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>x和y作为形参，两者互换，但不会影响到实参互换。</p>
<p>⚠️C语言中实参变量和形参变量之间的数据传递是<strong>单向传递</strong>，所以即便是通过指针的方式实现自定义swap函数的功能，也是<strong>将指针指向的存储空间中的量进行改变，而不是将指针本身的值（指针指向存储空间的地址）进行改变</strong>。</p>
<p>⚠️设有<code>int * p</code>定义的整型指针变量p，则形如<code>p = xxx</code>是改变指针变量的值，即指针变量指向的地址；形如<code>* p = xxx</code>是改变指针指向的地址中的内容，而指针的指向不变。</p>
<hr>
<p>看一个重要概念：（此处大量参考百度知道用户CodeBlove的内容，详情见<a href="https://zhidao.baidu.com/question/918644091176663379.html" target="_blank" rel="noopener">参考链接</a>）<br>⚠️⚠️⚠️<strong>二维数组和指针的指针间的关系</strong><br>二维数组名即数组地址，指向首行地址，不是指针的指针。</p>
<p>设有二维数组<code>int a[10][10]</code>，假设a等价于指针的指针，则设<code>int **p=a</code>; 那么要对行递增执行p++时，由于int <em>*是指指向一个 int </em>类型的指针，其数据宽度是4字节，内置宽度，因此p将指向下一个整数元素地址，也就是p递增了4字节，而不是10个int型数据的宽度，这就错位了。</p>
<p>所以a[10][10]的地址类型不是简单的指针的指针，应该是<code>int (*)[10]</code>,而不是int **。</p>
<p>设<code>int (*p)[10]=a</code>,其含义为，p是一个<strong>指向含10个int类型元素的一维数组或行的指针</strong>。</p>
<hr>
<h2 id="指针和数组"><a href="#指针和数组" class="headerlink" title="指针和数组"></a>指针和数组</h2><p>2、通过指针引用数组<br>指针存储地址，而数组名就是数组首元素的地址。<br>示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line">……	<span class="comment">//对a赋值</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, *(a+i));	<span class="comment">//但注意每次都要重新计算地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码可以依次输出数组的十个元素，a代表数组首元素地址，a+i代表第(i+1)个元素的地址，当进行a+i操作的时候，系统会自动根据a的基类型将i转换为相应的数字，比如此处a的基类型是int，则使用VC++ 6.0的系统自动将+i转换为+4。</p>
<p>*(a+i)引用数组元素的方法叫指针法，a[i]引用数组元素的方法叫下标法；</p>
<p>⚠️以上代码算不上真正的通过指针引用数组元素，在使用a[i]时，C编译器会将a[i]转化为<em>(a+i)，再计算元素地址，即使用a[i]和</em>(a+i)效率是相同的。</p>
<p>以下是利用指针的方式来输出数组中的全部元素：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(p=a; p&lt;(a+<span class="number">10</span>);p++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%d"</span>, * p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用指针变量直接指向元素，不必每次都重新计算地址，将指针在变量上进行移动（p++）也是较为迅速的操作。</p>
<p>调用自定义函数，传递参数的时候，系统是将形参数组名当作指针变量来处理的，以下两种写法是等价的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">func(<span class="keyword">int</span> a[], <span class="keyword">int</span> n);</span><br><span class="line">func(<span class="keyword">int</span> * a, <span class="keyword">int</span> n);</span><br></pre></td></tr></table></figure>
<p>3、通过指针引用<strong>多维</strong>数组<br>设有二维数组a[3][4]，则：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">指向第0行，即第0行首地址</td>
</tr>
<tr>
<td style="text-align:center">a+i</td>
<td style="text-align:center">指向第i行，即第i行首地址</td>
</tr>
<tr>
<td style="text-align:center">a[0]，<em>(a+0)，</em>a</td>
<td style="text-align:center">指向第0行第0个元素</td>
</tr>
<tr>
<td style="text-align:center">a[1]+2，*(a +1)+2，&amp;a[1][2]</td>
<td style="text-align:center">指向第1行第2个元素</td>
</tr>
<tr>
<td style="text-align:center">*(a[1]+2)，a[1][2]</td>
<td style="text-align:center">a[1][2]</td>
</tr>
<tr>
<td style="text-align:center"><em> (</em>(a+1)+2)</td>
<td style="text-align:center">a[1][2]</td>
</tr>
</tbody>
</table>
</div>
<p>理解上表，只需将二维数组想象成多行组成，每一行是一个一维数组。<br>⚠️&amp;a[i]或a+i指向行，a[i]或*(a+i)指向列</p>
<h5 id="指向二维数组的指针变量的两种方式："><a href="#指向二维数组的指针变量的两种方式：" class="headerlink" title="指向二维数组的指针变量的两种方式："></a>指向二维数组的指针变量的两种方式：</h5><p>（1）使用int *型指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;……&#125;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"><span class="keyword">for</span>(p=a[<span class="number">10</span>]; p&lt;a[<span class="number">0</span>]+<span class="number">12</span>; p++)&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"%4d"</span>, * p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（2）使用int(*)[4]型指针变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;……&#125;</span><br><span class="line"><span class="keyword">int</span> (* p)[<span class="number">4</span>]</span><br><span class="line">p = a;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, * (*(p+i)+j));</span><br></pre></td></tr></table></figure>
<p>（这种写法真是要多麻烦有多麻烦，反正博主是从来不用的）</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>引用数组元素的三种方式中，a[i]和*(a+i)的方式效率一样，都比较费时，因为每次都要重新计算地址，定义一个指针变量指向数组元素，通过指针变量自加操作遍历数组元素则较为高效；</p>
<p>⚠️要区分数组名a和指针p的区别，后者是指针变量，但前者<strong>a是指针常量</strong>，所以a++操作是行不通的。</p>
<h2 id="指针和字符串"><a href="#指针和字符串" class="headerlink" title="指针和字符串"></a>指针和字符串</h2><p>4、通过指针引用字符串<br>首先区别以下两种方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一</span></span><br><span class="line"><span class="keyword">char</span> * <span class="built_in">string</span>;</span><br><span class="line"><span class="built_in">string</span> = <span class="string">"deep dark fantasy"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式二</span></span><br><span class="line"><span class="keyword">char</span> * <span class="built_in">string</span>;</span><br><span class="line">*<span class="built_in">string</span> = <span class="string">"deep dark fantasy"</span>;</span><br></pre></td></tr></table></figure>
<p>不要认为以上两种方式是等价的，前者是将字符串的首地址赋给指针变量string，后者是将指针变量指向的地址的内容变成那个字符串；</p>
<p>再来看看字符串的输出方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, <span class="built_in">string</span>);</span><br></pre></td></tr></table></figure>
<p>%s是输出字符串时所用的格式符，再输出项中给出字符指针变量名string，则系统会输出string指向的字符串的第一个字符，然后自动使string加1，使之指向下一个字符，再输出该字符……直到遇到\0为止。用字符数组名或字符指针变量名都可以输出一个字符串，但是<strong>对于数值型数组，不能企图用数组名输出它的全部元素</strong>。</p>
<p>⚠️”deep dark fantasy”是字符串常量，C语言对字符串常量是按照字符数组处理的，在内存中开辟了一个字符数组来存放该字符串常量，但这个字符数组是没有名字的，因此不能通过数组名来引用，只能通过指针变量来引用。</p>
<p>5、<strong>字符指针变量和字符数组名的比较</strong><br>首先，调用函数时，函数的形参和实参都可以是字符数组名或字符指针变量中的一种。</p>
<p>接下来，讲讲两者在其他方面的使用异同：<br>字符数组名和字符指针变量保存的都是字符串第一个字符的地址，但是只能对后者赋值操作：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * a;</span><br><span class="line">a = <span class="string">"I am umbrellalalalala"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这样是没问题的，但下面的方法是错的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">14</span>];</span><br><span class="line">str = <span class="string">"I am umbrellalalalala"</span>;	<span class="comment">//数组名是地址，是常量，不能被赋值</span></span><br><span class="line">str[] = <span class="string">"I am umbrellalalalala"</span>;	<span class="comment">//这样赋值也是非法的</span></span><br><span class="line"><span class="comment">//如果是对单个数组元素赋值则没问题：str[0] = "I"</span></span><br></pre></td></tr></table></figure>
<p>⚠️定义了字符指针变量（或者其他指针变量）的时候，应当立刻给它赋值，否则它将指向一个未知的地址，如果给那个地址输入数据，同时那个地址碰巧是系统区之类的地方，则会出问题：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * a;	<span class="comment">//定义字符指针变量a，此时a指向的地址未知</span></span><br><span class="line"><span class="comment">//下面这个语句改变的不是a的指向，而是a指向的地址的内容！</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, a);	<span class="comment">//键盘输入一个字符串，字符串被存储到a指向的内存单元开始的一段连续内存单元中，</span></span><br><span class="line">							<span class="comment">//VC++ 6.0编译这种语句时会给出警告</span></span><br></pre></td></tr></table></figure>
<p>所以应当在定义了指针变量后，及时指定其指向。</p>
<p>看一个有趣的字符指针变量用法开开眼界：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">666</span>;</span><br><span class="line"><span class="keyword">char</span> * format;</span><br><span class="line">format = <span class="string">"%d\n"</span>;</span><br><span class="line"><span class="built_in">printf</span>(format, x);	<span class="comment">//输出666，换行</span></span><br></pre></td></tr></table></figure>
<h2 id="指针和函数"><a href="#指针和函数" class="headerlink" title="指针和函数"></a>指针和函数</h2><p>接下来总结博主从来没用过的函数指针。</p>
<p>6、函数指针定义和基本使用：<br>如果在程序中定义了一个函数，在编译时，编译系统为函数代码分配一段存储空间，这段存储空间的起始地址（又称入口地址）就是这个函数的指针。</p>
<p>使用指针变量访问用户自定义的函数：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;	<span class="comment">//用户自定义函数的声明</span></span><br><span class="line">	<span class="keyword">int</span> (*p)(<span class="keyword">int</span>, <span class="keyword">int</span>);	<span class="comment">//定义指向函数的指针变量p</span></span><br><span class="line">	p = max;			<span class="comment">//指针指向函数（将函数名“赋给”指针变量）</span></span><br><span class="line">	……</span><br><span class="line">	<span class="comment">//接下来使用自定义函数</span></span><br><span class="line">	c = (*p)(a, b);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span>	<span class="comment">//max函数的定义，略</span></span></span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>注意<code>(*p)</code>代表max函数，括号不能省略，因为<em>要和p先结合。如果写成了`int </em> p(int, int)<code>，这个是范围整型指针的p函数。
要先将函数入口地址赋给指针，才能用指针使用函数，注意地址赋值操作不能写成：</code>p = max(a, b)`<br>这样就变成了将函数所得到的函数值赋给p。</p>
<p>7、用指向函数的指针作函数参数<br>直接看用法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void func(int (* x1)(int), int (* x2)(int, int))&#123;</span><br><span class="line">	……</span><br><span class="line">	a = (* x1)(<span class="number">1</span>);</span><br><span class="line">	b = (* x2)(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果func经常需要调用不同的函数，也就是说func的参数经常要改变，那么这种情况下的函数指针的使用就非常方便了，只需要每次调用func时给出不同的函数名作为实参就行了。</p>
<h2 id="指针数组和多重指针"><a href="#指针数组和多重指针" class="headerlink" title="指针数组和多重指针"></a>指针数组和多重指针</h2><p>8、区分指针数组和“数组指针”<br>下面定义一个指针数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>下面定义一个指向一维数组的指针变量：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (* p)[<span class="number">4</span>];</span><br></pre></td></tr></table></figure>
<p>9、指向指针的指针<br>简单看一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *name[] = &#123;<span class="string">"deep"</span>, <span class="string">"dark"</span>, <span class="string">"fantasy"</span>&#125;;	<span class="comment">//定义一个指针数组，每个数组元素指向一个字符串</span></span><br><span class="line">	<span class="keyword">char</span> **p;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++)&#123;</span><br><span class="line">		p = name + i;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deep</span><br><span class="line">dark</span><br><span class="line">fantasy</span><br></pre></td></tr></table></figure>
<p>完♂美</p>
<p>依次类推，还可以定义<code>int ***</code>型，<code>int ****</code>型指针，但不常见也没必要。</p>
<p>10、动态分配内存<br>这里谭浩强的书上介绍了calloc、realloc、malloc、free函数，这里只介绍malloc和free，例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int *p, i, n;</span><br><span class="line">scanf(&quot;%d&quot;, &amp;n);	//可以在运行时指定数组大小</span><br><span class="line">p = (int *)malloc(n * sizeof(int));</span><br><span class="line">for(i=0; i&lt;n; i++)&#123;</span><br><span class="line">	scanf(&quot;%d&quot;, p+i);</span><br><span class="line">&#125;</span><br><span class="line">……</span><br><span class="line">free(p);	//使用完这个数组，将其指向的动态分配的空间释放</span><br></pre></td></tr></table></figure>
<p>这个代码段实现程序运行时再指定数组大小，并向数组中输入元素，使用完释放动态分配的空间。</p>
<p>11、void指针类型</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> * p;</span><br><span class="line">p = &amp;a;	<span class="comment">//相当于执行p = (void *)&amp;a</span></span><br></pre></td></tr></table></figure>
<p>执行后p得到a的<strong>纯地址</strong>，但<strong>不指向a</strong>，不能通过*p输出a的值。</p>
<p>12、指针的其他概念<br>（1）指针和指针变量<br>指针就是地址本身，指针变量是存储地址的变量。</p>
<p>（2）重点区分<code>int (* p)[4]</code>和<code>int * p[4]</code>：<br>前者是指向包含四个元素的一维数组的指针变量；后者是指针数组，包含四个指向整型数据的指针元素。</p>
<h1 id="用户自建数据类型"><a href="#用户自建数据类型" class="headerlink" title="用户自建数据类型"></a>用户自建数据类型</h1><h2 id="结构体及其使用"><a href="#结构体及其使用" class="headerlink" title="结构体及其使用"></a>结构体及其使用</h2><p>1、结构体定义和基本使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Date</span>	//定义一个叫<span class="title">Date</span>的结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> num;</span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> sex;</span><br><span class="line">	<span class="keyword">int</span> age;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">Date</span> <span class="title">birthday</span>;</span>	<span class="comment">//结构体可以“嵌套使用”，定一个 Date型的结构体变量名曰birthday，</span></span><br><span class="line">							<span class="comment">//作为Student结构体的成员</span></span><br><span class="line">	<span class="keyword">char</span> addr[<span class="number">30</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">student1</span>, <span class="title">student2</span>;</span>	<span class="comment">//利用定义好的结构体定义两个结构体变量</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Philosophy</span>&#123;</span>	<span class="comment">//定义结构体的同时定义结构体变量，可同时给结构体变量初始化，也可以不初始化</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> addr[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">char</span> profession[<span class="number">20</span>];</span><br><span class="line">&#125; Van = &#123;<span class="string">"Van"</span>, <span class="string">"next door"</span>, <span class="string">"artist"</span>&#125;, Billy;		<span class="comment">//注意分号的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//使用以上定义的结构体变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n%s\n%s\n"</span>, Van.name, Van.addr, Van.profession&#125;;</span><br></pre></td></tr></table></figure>
<p>C99标准允许对结构体变量的某一个成员进行初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个Student结构体变量b，只指定b的name</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">b</span> = &#123;</span>.name = <span class="string">"xiaoming"</span>&#125;;	<span class="comment">//name之前有成员运算符“.”</span></span><br></pre></td></tr></table></figure>
<p>如果未进行初始化，那么数值型成员会被系统初始化为0，字符型成员会被系统初始化为’\0’，指针型成员会被初始化为NULL。</p>
<p>注意以下操作，由于<code>.</code>运算符优先级最高，所以：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b.age++</span><br></pre></td></tr></table></figure>
<p>是对b的成员age进行自加操作。</p>
<p>同类的结构体变量可以互相赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">c</span>, <span class="title">d</span>;</span></span><br><span class="line">d = &#123;……&#125;;	<span class="comment">//初始化内容略</span></span><br><span class="line">c = d;	<span class="comment">//这样c的成员值和d的一样</span></span><br></pre></td></tr></table></figure>
<p>2、结构体数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">	<span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line">&#125;leader[<span class="number">3</span>] = &#123;<span class="string">"Li"</span>, <span class="number">0</span>, <span class="string">"Zhang"</span>, <span class="number">0</span>, <span class="string">"Sun"</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体数组名为leader，大小为3，上述初始化方式直接在大括号中方6个值，每个结构体变量有两个成员，这种方式恰能按序给三个数组元素赋值。</p>
<p>3、结构体指针<br>指向一个结构体变量的指针：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">e</span>;</span>	<span class="comment">//继续使用1中定义的结构体变量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> *<span class="title">p</span>;</span></span><br><span class="line">p = &amp;e;</span><br></pre></td></tr></table></figure></p>
<p>这样操作后，<code>e.name</code>和<code>(*p).name</code>以及<code>p-&gt;name</code>（常用）是一样的。</p>
<p>指向结构体数组的指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu</span>[3] = &#123;</span>&#123;stu[<span class="number">1</span>]的成员值&#125;, &#123;stu[<span class="number">2</span>]的成员值&#125;, &#123;stu[<span class="number">3</span>]的成员值&#125;&#125;;</span><br><span class="line"><span class="keyword">for</span>(struct Student * p = stu; p&lt;stu+<span class="number">3</span>; p++)</span><br><span class="line">	<span class="built_in">printf</span> (p当前指向的结构体变量);</span><br></pre></td></tr></table></figure>
<p>上述伪代码，p在循环中，依次指向结构体变量stu[1]、stu[2]、stu[3]。</p>
<p>还可以用结构体变量和结构体变量指针做函数参数，此处略。</p>
<h2 id="从来没用过的共用体"><a href="#从来没用过的共用体" class="headerlink" title="从来没用过的共用体"></a>从来没用过的共用体</h2><p>说实话，这部分内容过去也就在各种考试前看过，实际使用频率为0……但既然都写了这么多了，姑且就将这部分内容总结下：</p>
<p>4、共用体的三种声明和定义的形式：<br>（1）声明共用体的同时定义变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;a, b, c;</span><br></pre></td></tr></table></figure></p>
<p>（2）先声明共用体，再定义变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">union</span> Data a, b, c;</span><br></pre></td></tr></table></figure></p>
<p>(3)声明共用体的同时定义变量，但不说明共用体的名称：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span>&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;a, b, c</span><br></pre></td></tr></table></figure></p>
<p>5、共用体和结构体的区别：<br>结构体变量所占内存长度是各成员占的内存长度只和，每个成员分别占有其自己的内存单元。而共用体变量所占内存长度等于最长的成员的长度。</p>
<p>也就是说，共用体变量对应的同一个内存段可以用来存放几种不同类型的成员，但在每一瞬时只能存放其中一个成员。因为在每一个瞬时，存储单元只能有唯一的内容。例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;a;</span><br><span class="line">a.i = <span class="number">97</span>;</span><br></pre></td></tr></table></figure>
<p>表示将整数97存到共用体变量中，显然此时a中只有i有用户想要的值，但也不是不可以强行输出所有成员：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意97在内存中是01100001</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, a.i);	<span class="comment">//输出的是97</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%c"</span>, a.ch);	<span class="comment">//输出的是字母'a'，因为'a'的ASCII码是97</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%f"</span>, a.f);	<span class="comment">//输出0.000000</span></span><br></pre></td></tr></table></figure>
<p>按照浮点数形式输出为0的解释：<br>浮点数占32位，1位符号位+8位指数位+23位尾数位：<br><code>00000000，00000000，00000000，01100001</code>对于float型而言，指数位全是0，而实际上计算出来的指数要加127再作为指数位进行存储 。</p>
<hr>
<p>补充内容：<br>float型的2.0的存储方式，2.0写作二进制的科学计数法为：</p>
<script type="math/tex; mode=display">1.0\times2^1</script><p>符号位为0（正），指数位为$127+1=128=(10000000)_2$，尾数位是0（只取1.0的小数部位）<br>所以在内存中，以32位float型存储为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,10000000,00000000000000000000000	//1符号、8指数、23尾数</span><br></pre></td></tr></table></figure>
<hr>
<p>所以说，int型的97在内存中的二进制序列，以float型的眼光看待，就是0（个人认为理由是指数位全零是非法的，或者指数位全零是特指float型的0）。</p>
<p>判断对错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Data&#123;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span> ch;</span><br><span class="line">	<span class="keyword">float</span> f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span> Data a = &#123;<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">1.5</span>&#125;;		<span class="comment">//错误，不能初始化多个成员，它们占用同一段存储单元</span></span><br><span class="line"><span class="keyword">union</span> Data a = &#123;<span class="number">15</span>&#125;;	<span class="comment">//正确，对第一个成员初始化</span></span><br><span class="line"><span class="keyword">union</span> Data a = &#123;.ch=<span class="string">'j'</span>&#125;	<span class="comment">//正确，C99允许用这种方式对特定的成员初始化</span></span><br></pre></td></tr></table></figure>
<p>⚠️共用体变量中起作用的成员是最后一次被赋值的成员。</p>
<p>C99允许同类型的共用体变量相互赋值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b = a;	<span class="comment">//a和b都是同类型的共用体，合法</span></span><br></pre></td></tr></table></figure>
<p>但是不允许对共用体变量赋值，也不可以企图引用共用体变量名以得到一个值赋给非共用体变量。</p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>使用频率类似于switch语句，简单总结如下：<br>6、枚举类型介绍，直接看代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday&#123;sun, mon, tue, wed, thu, fri, sat&#125;;   <span class="comment">//enum用来声明枚举类型，大括号中的称为枚举元素</span></span><br><span class="line"><span class="keyword">enum</span> Weekday workday;	<span class="comment">//声明枚举变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//辨别正误：</span></span><br><span class="line">workday = mon;	<span class="comment">//正确，mon是指定的枚举常量之一</span></span><br><span class="line">workday = monday;		<span class="comment">//错误，monday不是指定的枚举常量之一</span></span><br><span class="line">mon = <span class="number">1</span>;		<span class="comment">//错误，不能以这种形式对枚举元素赋值</span></span><br></pre></td></tr></table></figure>
<p>枚举元素的引用和赋值：<strong>每一个枚举元素都代表一个整数</strong>，比如上面定义的Weekday中，sun为0，mon为1……所以赋值语句<code>workday = mon;</code>相当于<code>workday = 1</code>。可以将枚举常量当作整数输出：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, workday);</span><br></pre></td></tr></table></figure>
<p>输出的是1。依此类推，枚举常量还可以用作条件分支中整数之间的比较。<br>虽然枚举元素的值不能单独指定数值，但是可以在定义枚举类型的时候显示指定：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Weekday&#123;sun=<span class="number">7</span>, mon=<span class="number">1</span>, tue, wed =<span class="number">3</span>, thu, fri, sat&#125;workday, weekend</span><br></pre></td></tr></table></figure></p>
<h2 id="typedef的使用方法"><a href="#typedef的使用方法" class="headerlink" title="typedef的使用方法"></a>typedef的使用方法</h2><p>7、<br>个人认为typedef主要用于增强程序可读性的场合，博主参与算法竞赛期间没有用过，但写游戏这种设计大规模编程工作的任务中少不了它。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Integer;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">float</span> Real;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面两行执行后，下面两行等价</span></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line">Integer i;</span><br><span class="line"><span class="comment">//下面两行也等价</span></span><br><span class="line"><span class="keyword">float</span> f;</span><br><span class="line">Real f;</span><br></pre></td></tr></table></figure>
<p>代码讲得很清楚了，typedef就是给类型名重新起个名字使用，达到自己想要的可读性目标。<br>也可以用这个来简化复杂类型表示方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * (* (*)[<span class="number">10</span>])(<span class="keyword">void</span>)		<span class="comment">//指向包含10个元素的一维数组的指针，数组元素的类型为函数指针，</span></span><br><span class="line">							<span class="comment">//函数没有参数，函数的返回值是int指针</span></span><br></pre></td></tr></table></figure>
<p>是不是巨<del>鸡儿</del>（文明你我他）麻烦？这时候用typedef来简化十分方便，不过谭浩强系列书上没给这种的具体表示，估计实际中用不到，等我们能用到时再说，咱不深究这个问题。</p>
<p>再看一个例子，用typedef简化结构体（这可能是typedef最常用的地方，特别是在《数据结构》这门课中）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> month;</span><br><span class="line">	<span class="keyword">int</span> day;</span><br><span class="line">	<span class="keyword">int</span> year;</span><br><span class="line">&#125;Date;</span><br><span class="line"></span><br><span class="line">Date birthday;		<span class="comment">//定义结构体变量，不要写成struct Date birthday</span></span><br><span class="line">Date *p;			<span class="comment">//定义结构体指针变量p，指向此结构体类型数据</span></span><br></pre></td></tr></table></figure>
<p>简化数组：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Num[<span class="number">100</span>];</span><br><span class="line">Num a;	<span class="comment">//定义整型数组a，a中有100个元素</span></span><br></pre></td></tr></table></figure>
<p>简化指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type <span class="keyword">char</span> * String;</span><br><span class="line">String p, s[<span class="number">10</span>];		<span class="comment">//p为字符指针变量，s为字符指针数组</span></span><br></pre></td></tr></table></figure>
<p>简化数组指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">( * Pointer)</span><span class="params">()</span></span>;		<span class="comment">//Pointer是指向函数的指针类型，函数返回整型值</span></span><br><span class="line">Pointer p;			<span class="comment">//p为Pointer类型的指针变量</span></span><br></pre></td></tr></table></figure>
<h3 id="typedef记忆技巧："><a href="#typedef记忆技巧：" class="headerlink" title="typedef记忆技巧："></a>typedef记忆技巧：</h3><p>如果去掉typedef，剩下的部分应当是一个完整的变量或别的什么的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Num[<span class="number">100</span>];		<span class="comment">//Num是指定的名称</span></span><br><span class="line"><span class="comment">//去掉typedef后：</span></span><br><span class="line"><span class="keyword">int</span> Num[<span class="number">100</span>];		<span class="comment">//Num是被定义的变量</span></span><br></pre></td></tr></table></figure>
<h1 id="对文件的操作"><a href="#对文件的操作" class="headerlink" title="对文件的操作"></a>对文件的操作</h1><p>这部分就不总结了，用的不多，用时再查。</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/06/Notice-of-Deferred-Update/" rel="next" title="Notice of Deferred Update 关于推迟更新的通知">
                <i class="fa fa-chevron-left"></i> Notice of Deferred Update 关于推迟更新的通知
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Umbrellalalalala</p>
              <p class="site-description motion-element" itemprop="description">分享Umbrellalalalala的学术文章</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础知识"><span class="nav-number">1.</span> <span class="nav-text">基础知识</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#C语言基本要素"><span class="nav-number">2.</span> <span class="nav-text">C语言基本要素</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#变量、常量和数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">变量、常量和数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算数运算和数据存储"><span class="nav-number">2.2.</span> <span class="nav-text">算数运算和数据存储</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入输出函数"><span class="nav-number">2.3.</span> <span class="nav-text">输入输出函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关系运算符和逻辑运算符"><span class="nav-number">2.4.</span> <span class="nav-text">关系运算符和逻辑运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分支和循环"><span class="nav-number">2.5.</span> <span class="nav-text">分支和循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">2.6.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数注意事项和变量作用域、生存周期"><span class="nav-number">2.7.</span> <span class="nav-text">函数注意事项和变量作用域、生存周期</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#指针"><span class="nav-number">3.</span> <span class="nav-text">指针</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#指针基本概念"><span class="nav-number">3.1.</span> <span class="nav-text">指针基本概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针和数组"><span class="nav-number">3.2.</span> <span class="nav-text">指针和数组</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#指向二维数组的指针变量的两种方式："><span class="nav-number">3.2.0.0.1.</span> <span class="nav-text">指向二维数组的指针变量的两种方式：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#小结"><span class="nav-number">3.2.0.0.2.</span> <span class="nav-text">小结</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针和字符串"><span class="nav-number">3.3.</span> <span class="nav-text">指针和字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针和函数"><span class="nav-number">3.4.</span> <span class="nav-text">指针和函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#指针数组和多重指针"><span class="nav-number">3.5.</span> <span class="nav-text">指针数组和多重指针</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#用户自建数据类型"><span class="nav-number">4.</span> <span class="nav-text">用户自建数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#结构体及其使用"><span class="nav-number">4.1.</span> <span class="nav-text">结构体及其使用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从来没用过的共用体"><span class="nav-number">4.2.</span> <span class="nav-text">从来没用过的共用体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#枚举类型"><span class="nav-number">4.3.</span> <span class="nav-text">枚举类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#typedef的使用方法"><span class="nav-number">4.4.</span> <span class="nav-text">typedef的使用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#typedef记忆技巧："><span class="nav-number">4.4.1.</span> <span class="nav-text">typedef记忆技巧：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#对文件的操作"><span class="nav-number">5.</span> <span class="nav-text">对文件的操作</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Umbrellalalalala</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
